{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2019/06/24/derived-state",
    "result": {"data":{"markdownRemark":{"html":"<p>A lot of advice in the React community is focused around avoiding explicitly storing “derived state” of some type or another.  Some examples of this type of “derived state” that the community warns against:</p>\n<h4>Storing data that is directly derived from another piece of data in redux</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> reducer <span class=\"token operator\">=</span> <span class=\"token function\">createReducer</span><span class=\"token punctuation\">(</span>initialState<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">ADD_USER</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">state<span class=\"token punctuation\">,</span> action</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    state<span class=\"token punctuation\">.</span>users <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>state<span class=\"token punctuation\">.</span>users<span class=\"token punctuation\">,</span> action<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// numUsers is derived state: it will always be tied to users</span>\n    state<span class=\"token punctuation\">.</span>numUsers <span class=\"token operator\">=</span> state<span class=\"token punctuation\">.</span>users<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h4>Storing state that is directly derived from a prop in a component</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Widget</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">props</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// the hasError state is derived from the error prop</span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>hasError<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token operator\">!</span>props<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//... continued ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>Storing state that is directly derived from another piece of state</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">NameForm</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token literal-property property\">firstName</span><span class=\"token operator\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>\n            <span class=\"token literal-property property\">lastName</span><span class=\"token operator\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>\n            <span class=\"token literal-property property\">fullName</span><span class=\"token operator\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// because fullName is directly associated with firstName and lastName, we have to update it</span>\n    <span class=\"token comment\">// any time they are updated</span>\n    <span class=\"token function\">updateFirstName</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">newFirstName</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">state</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n            <span class=\"token operator\">...</span>state<span class=\"token punctuation\">,</span>\n            <span class=\"token literal-property property\">firstName</span><span class=\"token operator\">:</span> newFirstName<span class=\"token punctuation\">,</span>\n            <span class=\"token literal-property property\">fullName</span><span class=\"token operator\">:</span> newFirstName <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> state<span class=\"token punctuation\">.</span>lastName<span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">updateLastName</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">newLastName</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">state</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n            <span class=\"token operator\">...</span>state<span class=\"token punctuation\">,</span>\n            <span class=\"token literal-property property\">lastName</span><span class=\"token operator\">:</span> newLastName<span class=\"token punctuation\">,</span>\n            <span class=\"token literal-property property\">fullName</span><span class=\"token operator\">:</span> state<span class=\"token punctuation\">.</span>firstName <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> newLastName<span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// ... continued ....</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>These examples are all based on real-world code I’ve seen.  And they all were in code that <em>worked</em>, the program executed as expected.  But they’re still problematic.  This type of derived state is error-prone; when new code is written to update the state, each new programmer touching the code has to understand the relationship, or the whole thing can get out of sync.  When state is coming from props, like the error example above, you have to make sure that the state gets updated properly when the props change. And when the state gets out of sync, it is possible to end up in strange states where a programmer’s expectations are violated.  A program shows a blank state saying no users have been added, even though one has already been created. A form is expecting to have an error, but the error text is empty or set to a default value.  Or a site has 2 different names for an individual that show up differently in separate parts of the interface.</p>\n<p>This type of problem isn’t a new thing in Computer Science.  When programmers do it by accident they usually call it a <a href=\"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself\">DRY violation</a>.  When they do it intentionally they call it caching.  And when they do it intentionally but screw things up, they <a href=\"https://twitter.com/secretGeek/status/7269997868\">make jokes about off by one errors</a>.  Fortunately, that means that the tradeoffs are pretty well understood here.  So how do we handle situations where it looks like derived state may be necessary?</p>\n<h4>Just Derive State At Render Time</h4>\n<p>For many many things, including the 3 examples above, if you need information at render time that can be derived from other pieces of state, it’s totally fine to just calculate it at render time.  For the first name example above, you can just include a <code class=\"language-text\">let fullName = this.state.firstName + ' ' + this.state.lastName;</code> line at the top of your render function and move on<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>. Storing derived information is unnecessary and harmful when calculating it at runtime adds minimal performance overhead or repetition.</p>\n<h4>Memoization</h4>\n<p>But Ben, my component is slow now!</p>\n<p>…are you sure it’s actually slow?  Have you tested it?  Have you proven that the derived state calculation is actually a meaningful part of this?</p>\n<p>Deriving state can be slow when you have to do complicated calculations or reformatting of data.  This is still not usually a problem, but if you’re in a performance sensitive area of code and have proven it to be a problem, you can start considering caching solutions. You still don’t want to store your cached values in state or your redux stores though.  Instead, you want to use a computed value that is recalculated when its inputs change.  The exact code will depend on your state management strategy, but some examples out there include</p>\n<ul>\n<li><a href=\"https://github.com/reduxjs/reselect\">Reselect for Redux</a></li>\n<li><a href=\"https://mobx.js.org/refguide/computed-decorator.html\">Computeds in MobX</a></li>\n<li><a href=\"https://reactjs.org/docs/hooks-reference.html#usememo\">useMemo in React Components</a></li>\n</ul>\n<p>All of these methods use <em>memoization</em>, a type of caching where arguments are passed to a function, and if the function has been called with those arguments before, it returns the previous result rather than recomputing.  If for instance we had a component and wanted to get the names of all <code class=\"language-text\">users</code> with the current <code class=\"language-text\">type</code> based on props, and we knew that <code class=\"language-text\">users</code> was sometimes quite large, making the calculations slow, and we expected the component to re-render often for some reason or another we might write code like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">UsersList</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span>users<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">let</span> userNames <span class=\"token operator\">=</span> <span class=\"token function\">useMemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> users<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">user</span> <span class=\"token operator\">=></span> user<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>users<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ... continued ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now userNames will automatically be recalculated only when users or type changes<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>.  The MobX and Redux solutions work similarly.  Memoization isn’t a performance silver bullet: at some point, you might have to look at how you can make your calculations less expensive or take them off of the rendering path completely.  But for most simple data transformation tasks, deriving state at render time and using memoization to keep it performant where needed should help you tame any derived state problems you encounter.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">But you should probably read about all the ways that <a href=\"https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/\">names can be more complicated than you think</a><a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">Note that useMemo (and most memoization solutions generally) doesn’t guarantee the function will never run more than once.  Most solutions have a limited number of results they will store, so if the inputs change often, the result might get recalculated.<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","frontmatter":{"title":"Avoiding Derived State In React","keywords":"","category":"fe-architecture","date":"2019/06/24","path":"/2019/06/24/derived-state","layout":"post","hideFooter":null,"hideSidebar":null},"fields":{"slug":"/2019/06/24/derived-state"}}},"pageContext":{"slug":"/2019/06/24/derived-state","relatedPosts":[{"path":"/2019/04/01/consistency","data":{"title":"Consistency","path":"/2019/04/01/consistency","description":"How do we encourage standards in a code base without losing perspective?","date":"2019/04/01","category":"software-productivity"}},{"path":"/2019/02/11/reusable-react","data":{"title":"Reusable Code In React: Inheritance, Composition, Decorators and Mixins","path":"/2019/02/11/reusable-react","description":"How React uses multiple code sharing patterns to create a great developer experience","date":"2019/02/11","category":"fe-architecture"}},{"path":"/2018/07/09/book-review-five-dysfunctions/","data":{"title":"Book Review: The Five Dysfunctions of a Team","path":"/2018/07/09/book-review-five-dysfunctions/","description":"A book on how teams fall apart, and how to keep them together","date":"2018/07/09","category":"reviews"}}]}},
    "staticQueryHashes": []}